# 递归

递归只是让解决方案更清晰，并没有性能上的优势。  
使用循环，程序的性能可能会更高。

## 基线条件和递归条件

每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。
递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。

eg:

```js

function countdown(i) {
  console.log(i)
  if (i <= 0) {
    return
  } else {
    countdown(i - 1)
  }
}

countdown(5)

```

## 栈

调用栈（call stack）

两种操作 压入（插入）push，弹出（删除并取出）pop

### 调用栈

调用一个函数，会分配一块内存。函数调用涉及的所有变量的值存储到内存中。
压入调用栈，函数运行完成后，弹出调用栈。
函数内调用函数，会分配新的一块内存并压入调用栈，此时，调用的函数称为当前运行的函数，

### 递归调用栈

使用栈虽然很方便，但是也要付出代价:存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况 下，你有两种选择。

* 重新编写代码，转而使用循环。
* 使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言
都支持尾递归。
