/*
 * @lc app=leetcode.cn id=96 lang=javascript
 *
 * [96] 不同的二叉搜索树
 */

// TODO

// @lc code=start
/**
 * @param {number} n
 * @return {number}
 */
function numTrees(n) {
  // 动态规划
  // 函数定义
  // G(n): 长度为n的序列能构成的不同二叉搜索树的个数。
  // F(i,n): 以i为根、序列长度为n的不同二叉搜索树的个数(1 <= i <= n)。
  // 不同的二叉搜索树的总数G(n)，就是对遍历所有i(1 <= i <= n)的F(i,n)之和
  // 故 G(n) = F(1, n) + F(2, n) + ... + F(i, n) + ... + F(n, n)
  // 边界情况当序列长度为0（空树）或1（只有根）时，只有一种情况 G(0) = G(1) = 1
  // 举例而言，创建以3为根、长度为7的不同二叉搜索树，
  // 整个序列是[1,2,3,4,5,6,7]，我们需要从左子序列[1,2]构建左子树，
  // 从右子序列[4,5,6,7]构建右子树，然后将它们组合（即笛卡尔积）。
  // F(i, n) = G(i - 1) * G(n - i)
  // 结合两个公式可以得出
  // G(n) = G(0)*G(n-1) + G(1)*G(n-2) + G(i-1)*G(n-i) + ... + G(n-1)G(0)
  // 其实也就是卡塔兰数
  // 时间复杂度O(n^2): n为二叉搜索树的节点个数。G(n)一共有n个值需要求解，每次求解的时间复杂度为O(n)
  // 空间复杂度O(n): 需要n长度的数组存储G数组。
  const G = new Array(n + 1).fill(0);
  G[0] = 1;
  G[1] = 1;

  for (let i = 2; i <= n; i += 1) {
    for (let j = 1; j <= i; j += 1) {
      G[i] += G[j - 1] * G[i - j];
    }
  }
  return G[n];
}
// @lc code=end

const res1 = numTrees(3); // 5
