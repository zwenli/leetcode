# 位运算

位运算是对二进制数的操作。

人习惯十进制

计算机是用二进制数，电位高低，分别1、0

## 十进制与二进制的互相转换



## 位运算符

|运算符合|含义|示例|
|--|--|--|
| `&` | **AND**按位与 | `0110 & 1010 = 0010` |
| `|` | **OR**按位或 | `0110 | 0011 = 0111` |
| `~` | **NOT**按位取反 | `~0110 = 1001` |
| `^` | **XOR**按位异或，（相同为0，不同为1，也可以理解为不进位加法） | `0110 ^ 1010 = 1100` |
| `<<` | 左移 | `101001 >> 2 = 001010` |
| `>>` | 右移 | `101001 << 2 = 100100` |


### XOR 异或

异或：相同为0，不同为1。也可以理解为不进位加法

异或操作的一些特点：

```
x ^ 0 = x // 0110 ^ 0000 = 0100
x ^ 1s = ~x // 注意1s = ~0, 0110 ^ 1111 = 1001 = ~0110
x ^ (~x) = 1s // 0110 ^ (~0110) = 0110 ^ 1001 = 1111
x ^ x = 0 // 0110 ^ 0110 = 0000
c = a ^ b => a ^ c = b, b ^ c = a // 交换两数字
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative
```

### 指定位置的位运算

1. 将x最右边的n位清零：x & (~0 << n)
2. 获取x的第n位的值（0或者1）： (x >> n) & 1
3. 获取x的第n位的幂值： x & (1 << (n - 1))
   1. `111001 & (000001 << (4 -1)) = 111001 & 001000 = 001000`
4. 仅将第n位置为1： x | (1 << n)
5. 仅将第n位置为0： x & (~(1 << n))
6. 将x的最高位至第n位清零（含n）： x & ((1 << n) - 1)
   1. `011011 & ((000001 << 3) - 1) = 011011 & (001000 - 1) = 011011 & 000111 = 000011`
7. 将x的第n位到第0位（含）清零： x & (~((1 << (n + 1)) - 1))
   1. `011011 & (~((000001 << (3 + 1)) - 1)) = 011011 & (~(010000 -1))`
   2. `= 011011 & (~(001111)) = 011011 & 110000 = 010000`

### 实战位运算要点

* 判断奇偶

  ```
  x % 2 == 1   ->   (x & 1) == 1

  x % 2 == 0   ->   (x & 1) == 0
  ```

* x / 2 -> x >> 1

  即：x = x / 2; -> x = x >> 1;

    mid = (left + right) / 2 -> mid = (left + right) >> 1;

* x = x & (x - 1) 清零最低位的1

  ```
  011010 & (011010 - 000001)
  = 011010 & 011001
  = 011000
  ```

* x & (-x) 得到最低位的1
* x & (~x) == 0


## 二进制的原码、补码、反码

https://zhuanlan.zhihu.com/p/99082236
https://blog.csdn.net/u014082714/article/details/43193173

这其实涉及到了二进制的正负数，加减问题

x + (-x) = 0

>假设有一个 int 类型的数，值为3，那么，我们知道它在计算机中表示为：
>
>00000000 00000000 00000000 00000011
>
>因为int类型的数占用4字节（32位），所以前面填了一堆0。
>
>在计算机中，负数以其正值的补码形式表达。
>
>什么叫补码呢？这得先从原码，反码说起。
>
>原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。
>
>比如 00000000 00000000 00000000 00000011 是 3的 原码。
>
>反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。
>
>取反操作指：1变0；0变1
>
>比如：00000000 00000000 00000000 00000011的反码是11111111 11111111 11111111 11111100。　
>
>补码：反码加1称为补码。
>
>也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。
>
>比如：00000000 00000000 00000000 00000011 的反码是：11111111 11111111 11111111 11111100。
>
>那么，补码为：
>
>11111111 11111111 11111111 11111100 + 1 = 11111111 11111111 11111111 11111101
>
>所以，-3 在计算机中表达为：11111111 11111111 11111111 11111101。转换为十六进制：0xFFFFFFFD。


## 题目

* https://leetcode-cn.com/problems/number-of-1-bits/
* https://leetcode-cn.com/problems/power-of-two/
* https://leetcode-cn.com/problems/reverse-bits/
* https://leetcode-cn.com/problems/n-queens/description/
* https://leetcode-cn.com/problems/n-queens-ii/description/
* https://leetcode-cn.com/problems/counting-bits/description/
